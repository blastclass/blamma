This is a project designed to bring a familiar paradigm to OT professionals to the browser, so that implementing SCADA-like control, indicators, visualizations, alarms, etc. can be done in a familiar way using an MQTT-like broker to communicate and retain state information in real time in a structured way.  broker.mjs -- a shared worker that serves as a message broker in the style of MQTT with retain flag set, backed up by localStorage. client.mjs -- a script that manages the messaging with the broker to report/receive state changes. shared-checkbox.mjs -- a custom html component that uses the client.js messaging to manage its state (checked).  The id of the element is prefix of the topic.  <shared-checkbox id="ck1"></shared-checkbox> would be publishing to ck1/mouseover and ck1/checked and would GET ck1/checked to set its state to begin with, then SUB to ck1/checked to be notified if another client changes ck1/checked.    HOT retrieves the list of topics to which payloads have been published during this session. ALL retrieves the list of all topics(keys) present in localstorage. SET or PUB stores a key/value (topic/payload) pair in localstorage, triggering distribution to subscribers SUB subscribes to a single topic GET retrieves the retained value (from localstorage, if any) BYE client is disconnecting, so unsub(CLR) all topics and update clients, HOT, etc. CLR cancels a topic subscription BIR birth message with clientID and status message, and maybe subs.   SYS ack, response and status messages from broker to client, "connected" "subscribed" etc. QRY query the historical data TODO ERR try/catch error report.  published to $SYS/Errors.{ topic:"button1/click",payload: {x:23,y:45,button:0} } { topic:"text1/mouseenter" } { type: "SUB", topic: "text1/mouseenter" or topics:["text1/mouseenter","text2/mouseenter"]} { type: "PAT",  topic: "*/mouseenter" } { type: "SYS", topic: "subscribe-pattern-success", payload: [<matching topics subscribed>]} { type: "HLO", topic: "status", payload: { status:"connecting.", clientID: <clientID>, pub: ["status","alarm","error"], sub: ["$SYS/clientCount","$SYS/topicCount","$HIS/MB","$HIS/QRY"], pat: ["button*","checkbox*"] } { type: "BYE" }  use localStorage as a persistent record of the last values published on each topic.  It is the single source of truth for the domain context.  state, context, session, etc. are synonymous for all shared-components.  components should always reflect the state in the localStorage, so if a publish fails, a GET will expose the failure.  alternatively, an ack can be sent back to the publisher after the change has been stored.  Or the PUB always entails SUB, such that the shared-checkbox is updated if the stored state differs/failed.   If possible, it would be nice to be able to include three tags, <shared-broker>, <shared-client> and <shared-checkbox>.  All of the clients are managing the states of the shared-components based on messages received from the shared-broker, and is also publishing detailed telemetry about itself, once the state is properly represented.  This may all seem a little clunky, but we are modeling HTML form elements IIoT-style, with a Unified Namespace (UNS -- as described by Walker Reynolds)  We aren't going with ISA-95 or anything like that, instead we are modeling the state of the context a user has with a specific domain.  Let's use blamma.com as the example domain.  It is running PHP 8.3 and there is a MariaDB 10.5 Standard there.  with a table named uns with fields topic and payload  Occasionally, the shared-worker should post it's entire localStorage to the topic of its clientID, chosen when first instantiated and finding that there is no "clientID" topic in localStorage.  A post to blamma.com/post.php?client_a45ert0 with payload as the post body should INSERT INTO uns (topic, payload) VALUES . . .  Create a shared-debug component that pops up 50% opaque over the bottom third of the document viewport.  It is a textarea that is displaying BIR and BYE and ERR messages.  The label accepts clicks to show/hide the status area.  Create a shared-selectMultiple that shows the HOT list, and subscribes to any selected, outputting to the shared-debug.  Create a shared-tabs component to display the active clients.  So if I open Page1.html, when I open Page2.html, there are two tabs at the top, the active Page2.html tab, and the Page1.html tab that is open in a different browser tab I have Page1.html open in.  If I switch back to Page1.html, it now has a Page2.html tab, although the Page1.html tab is being shown.  The clientID of each of the shared-client instance is the filename (Page1.html, Overview.html, whatever).  So Page1.html/load would contain information about when that client first connected to the broker, how many times it has reconnected (refresh or different day or timeout).  Let's consider ck1/checked as the state/topic/key associated with something named "ck1".  Page1.html/ck1/checked is the state of the <shared-checkbox id="ck1"> on Page1.html.  Page1.html is subscribed to ck1/checked, and if ck1/change comes with a from/to on property "checked" then the shared-checkbox should ensure the element reflects the ck1/checked state managed by the broker.  As such, once the user checks the checkbox, it should publish this change, and then GET the value and reset based on what was returned.  The effect of this is that it appears the checkbox is now checked, but if storing the state failed, or a race-condition comes about, the actual value of the ck1/checked is displayed.  (If the operation failed when storing the state, or a different client already changed it back, then the checkmark would uncheck itself in preparation of retrying the click operation to re-check the checkbox).  This sort of pattern is important to keep the localStorage value as the single source of truth across the application and that no clients are not displaying stale data or in danger of sending invalid messages based on stale data. But dealers choice how this happens, through implied SUB with a PUB/SET, or by sending a GET message.  Create a broker-telemetry component that subscribes and shows an htop-like view of the messages, remaining localStorage, number of connected clients, etc.  Be exhaustive, and consider the sorts of data that would be most interesting for benchmarking when creating the broker.mjs.  $SYS/ topic should be very chatty with a log output and many reportable stats.  A debug-level would be useful for this.  Create a shared-toast component that pops up the same toast on all pages using the shared-toast.     Create a mode-line component that allows entry of PUB/SUB topics that show up as an unshared-toast.  Create a shared-slider component using the <input type="range">.  Create a shared-theme component that allows the selection of theme colors and fonts and things to be user-editable.  default to gruvbox.  Basically this is a matter of applying CSS stored in the shared state.  There should also be the capability to also keep a specific client/app/page to be cascaded such that each may also have its own styles stored in the shared state.  Create a mouse-sensor component that reports all mouse and touch events to the broker.  Create a hotkey-sensor component that allows a hotkey combination to fire a custom onhotkey event.   events that might be interesting for various things: onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting  I'm confident in your ability to spin up a working prototype of this setup such that adding additional functionality and shared-state UI elements is straight-forward.  So think as long as you need to, and DO NOT include comments for now.  I don't need any explication at all, only the files necessary to get up and running when I drop them into a local web server I already have running.  Conserve your tokens for thinking deeper into a working prototype.  predict issues that could arise later in the cycle that you can solve with better design from the beginning.  Don't use const or let at this point. var only.  we will know our code is "polished" by whether there are still var's.  We are in ultra-draft mode.  Like it was something I just banged out from an idea I had.  Do not use end-of-line semicolons.  Only use semicolons where absolutely necessary. spaces around operators(' == '), after opening brackets, and after commas, etc. 2 space tabs.

I just realized that localStorage is not available in SharedWorker context.  So use IndexedDB instead.
